---
title: "Going further with R - session 2/2"
author: GÃ©raldine Derroire
institute: Cirad - UnB
date: last-modified
format: 
  revealjs:
    theme: solarized
    output-location: fragment 
    slide-number: true
    preview-links: true
    chalkboard: true
    link-external-icon: true
    link-external-newwindow: true
    incremental: true
execute:
  echo: true   
  warning: true
  message: true 
  cache: true
editor: 
  markdown: 
    wrap: sentence
---

# 

Let's load the package we will use:

```{r}
#| message: false
library(tidyverse)
```


```{r, echo=FALSE}
set.seed(14)
```


# Conditional execution

**Conditional execution** means running different blocks of code depending on whether a condition is TRUE or FALSE.

## if

[Let's write a function saying *Bom dia* only in the morning:]{style="font-size: 30px"}

```{r}
greeting <- function(time) {
  time <- hm(time) 
  time_limit <- hm("11:59")
  if (time < time_limit) {
    message("Bom dia !")
  } 
}
```

[ðŸ’¡ The function [hm]{style="color:indianred;"} from [lubridate]{style="color:indianred;"} convert a character to a period object.]{style="font-size: 25px"}

::: fragment
```{r}
greeting("8:13")
```
:::

::: fragment
```{r}
greeting("14:25")
```
:::

::: notes
very important function for me!!!
:::

## if 

![](if.png)

The command [if]{style="color:indianred;"} is used with:

* a condition (in parentheses)

* a block of code (in curly brackets) that is executed only if the condition is TRUE


## if / else

[Let's update our function to say *Boa tarde* in the afternoon:]{style="font-size: 30px"}

```{r}
greeting <- function(time) {
  time <- hm(time) 
  time_limit <- hm("11:59")
  if (time < time_limit) {
    message("Bom dia !")
  } else {
    message("Boa tarde !")
  }
}
```

[[and test it:]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r}
greeting("8:13")
```
:::

::: fragment
```{r}
greeting("14:25")
```
:::

## if/else

An [if]{style="color:indianred;"} instruction can be followed by a [else]{style="color:indianred;"} that is executed if the condition of [if]{style="color:indianred;"} is FALSE.

![](if_else.png)

## if/else if/else

[But what to say in the evening?]{style="font-size: 30px"}

```{r}
greeting <- function(time) {
  time <- hm(time) 
  time_limit1 <- hm("11:59")
  time_limit2 <- hm("17:59")
  if (time < time_limit1) {
    message("Bom dia !")
  } else if (time < time_limit2) {
    message("Boa tarde !")
  } else {
    message("Boa noite !")
  }
}
```

[[let's check]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r}
greeting("8:13")
```
:::

::: fragment
```{r}
greeting("14:25")
```
:::

::: fragment
```{r}
greeting("20:17")
```
:::

## if/else if/else

We can add a second condition with [else if]{style="color:indianred;"}. 
The second condition is tested only if the 1st condition is FALSE.

![](if_else_if_else.png)


## Order of conditions

[Only the block of the first TRUE condition is executed.]{style="font-size: 30px"}

[âš ï¸ **The order of conditions is therefore important!**]{style="font-size: 30px"}

```{r}
greeting_wrong <- function(time) {
  time <- hm(time) 
  time_limit1 <- hm("11:59")
  time_limit2 <- hm("17:59")
  if (time < time_limit2) {
    message("Boa tarde !")
  } else if (time < time_limit1) {
    message("Bom dia !")
  } else {
    message("Boa noite !")
  }
}
```

::: fragment

ðŸ¥´

```{r}
greeting_wrong("8:13")
```
:::

::: notes
explain what happen following the code
:::

## 

[ðŸ’¡ Now that we understand, we can use a more concise syntax for our function:]{style="font-size: 30px"}

```{r}
greeting <- function(time) {
  if (hm(time)  < hm("11:59")) {
    message("Bom dia !")
  } else if (hm(time)  < hm("17:59")) {
    message("Boa tarde !")
  } else {
    message("Boa noite !")
  }
}
```

::: notes
if removed the 3 first lines and included the hm() in the tests
:::


## Example of use

[We can modify our function *mean_diam* so that it rounds the diameter only if a value is given to the argument digits.]{style="font-size: 30px"}
[[For that we give the default value NULL to the argument *digits*, and add a test before rounding:]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r}
mean_diam <- function(circ, na_act = TRUE, digits = NULL) {
    diam <- circ / (pi * 100) # Calculate diameters in m
    mean_diam <- mean(diam, na.rm = na_act) # Calculate the mean 
  # Round the diameter only if a value is provided for digits
    if(!(is.null(digits))) {
      mean_diam <- round(mean_diam, digits = digits)
    }
    return(mean_diam) # Return the mean diameter
}
```
:::

::: fragment
```{r}
new_circ <- runif(n = 35, min = 30, max = 250)
mean_diam(new_circ)
```
::: 

::: fragment
```{r}
mean_diam(new_circ, digits = 3)
```
::: 

## Another example 

What does this function do?

```{r}
graph_var <- function(v) { # v: a vector
    if (is.character(v)) {
        barplot(table(v))
    } else if (is.numeric(v)) {
        hist(v)
    } else {
        message("The type of v is not supported by the function")
    }
}
```

## Another example 

[Let's check:]{style="font-size: 30px"}

::::: columns
::: {.column width="50%"}
```{r}
v_char <- sample(LETTERS[1:5], 100, 
                 replace = TRUE)
graph_var(v_char)
```


:::

::: {.column width="50%"}
```{r}
v_num <- runif(100, min=0, max=10)
graph_var(v_num)
```

:::
:::::

```{r}
vec_logical <- sample(c(TRUE, FALSE), 100, replace = TRUE)
graph_var(vec_logical)
```

## Writing conditions

[To write conditions, we use can:]{style="font-size: 30px"}

* [logical operator: [<]{style="color:indianred;"}, [>]{style="color:indianred;"}, [<=]{style="color:indianred;"}, [>=]{style="color:indianred;"}, [%in%]{style="color:indianred;"}, [==]{style="color:indianred;"}, [!=]{style="color:indianred;"}, [any]{style="color:indianred;"}, [all]{style="color:indianred;"}...]{style="font-size: 30px"}

* [type checking functions: [is.numeric]{style="color:indianred;"}, [is.character]{style="color:indianred;"}, [is.logical]{style="color:indianred;"}...]{style="font-size: 30px"}

[[and combine them using [&&]{style="color:indianred;"} and [||]{style="color:indianred;"}]{style="font-size: 30px"}]{.fragment}

[[ðŸ’¡ [&&]{style="color:indianred;"} and [||]{style="color:indianred;"} are equivalent to [&]{style="color:indianred;"} and [|]{style="color:indianred;"} but only work for vector of length one. There are therefore safer to use in if/else conditions, as they need to return only one value.]{style="font-size: 30px"}]{.fragment}


## More complex conditions

```{r}
check_input <- function(x, valid_val) {
  if(length(x) != 1 || !(x %in% valid_val)) {
    cat(x, "is an invalid input.")
  } else {
    cat(x, "is a valid input.")
  }
}
```

::: fragment
```{r}
check_input(x = 2, valid_val = 1:10)
```
:::

::: fragment
```{r}
check_input(x = 25, valid_val = 1:10)
```
:::

::: fragment
```{r}
check_input(x = c(2,3), valid_val = 1:10)
```
:::



## More complex conditions

Should we go the the party?

```{r}
tricky_decision <- function(cool_people, good_music) { # booleans
  if(cool_people && good_music) {
    message("Go!") 
  } else if (cool_people || good_music) {
    message("Maybe...")
  } else {
    message("No way!")
  }
}
```

[ðŸ’¡ As the expected values for the two arguments are booleans, we don't need to write == TRUE.]{style="font-size: 30px"}

::: notes
Let's see if you remember how to combine tests...
What does this function do?
:::

## More complex conditions

```{r}
tricky_decision(cool_people = TRUE, good_music = TRUE)
```

```{r}
tricky_decision(cool_people = TRUE, good_music = FALSE)
```

```{r}
tricky_decision(cool_people = FALSE, good_music = TRUE)
```

```{r}
tricky_decision(cool_people = FALSE, good_music = FALSE)
```

## if/else and ifelse

[âš ï¸ [if/else]{style="color:indianred;"} and [ifelse]{style="color:indianred;"} (or its [tidyverse]{style="color:indianred;"} equivalent [if_else]{style="color:indianred;"}) are very different:]{style="font-size: 30px"}

::::: columns
::: {.column width="50%"}

* [[if/else]{style="color:indianred;"} is used when testing a single condition and execute different blocks of code depending on its result:]{style="font-size: 30px"}

::: fragment
```{r}
x <- 5
if (x >= 10) {
    message(">=10")
} else {
    message("<10")
}
```
:::
:::

::: {.column width="50%"}
* [[ifelse]{style="color:indianred;"} and [if_else]{style="color:indianred;"} apply a test to all the elements of a vector and return a vector whose elements depend on the result of each test:]{style="font-size: 30px"}

::: fragment
```{r}
x <- 5:15
ifelse(x >= 10, ">=10", "<10")
```
:::
:::
:::::


## Using [if/else]{style="color:indianred;"} to control the execution of a function

[Our function [mean_diam]{style="color:indianred;"} is meant to be used on a numerical vector. It returns an error otherwise:]{style="font-size: 30px"}

```{r, eval = FALSE}
vec_char <- c("A", "B")
mean_diam(vec_char)
```
```{r, echo= FALSE}
vec_char <- c("A", "B")
try(mean_diam(vec_char))
```

[[This error is not explicit for a user, as they don't know what *circ/(pi \* 100)* is used for...]{style="font-size: 30px"}]{.fragment}


## Using [if/else]{style="color:indianred;"} with [warning]{style="color:indianred;"}

[We can add a test to return *NA* when *circ* is not numeric, and add an explicit warning message:]{style="font-size: 30px"}

```{r}
mean_diam <- function(circ, na_act = TRUE, digits = NULL) {
    if(!(is.numeric(circ))) {
      warning("circ is not numeric, the result is NA")
      return(NA) # if circ is not numeric, the execution stops here
    }
  
    diam <- circ / (pi * 100) # Calculate diameters in m
    mean_diam <- mean(diam, na.rm = na_act) # Calculate the mean 
    if(!(is.null(digits))) { # Round the diameter only if a value is provided for digits
      mean_diam <- round(mean_diam, digits = digits)
    }
    return(mean_diam) # Return the mean diameter
}
```

::: fragment
```{r}
mean_diam(vec_char)
```
:::

::: notes
Many parenthesis, click on a closing one to see which one it closes
:::

## Using [if/else]{style="color:indianred;"} with [stop]{style="color:indianred;"}

[[warning]{style="color:indianred;"} does not stop the execution of the function (in our previous slide it's [return]{style="color:indianred;"} that stopped it).]{style="font-size: 30px"}

::: fragment
[[On the contrary, [stop]{style="color:indianred;"} triggers an error that stops the execution:]{style="font-size: 30px"}]{.fragment}

```{r}
mean_diam <- function(circ, na_act = TRUE, digits = NULL) {
    if(!(is.numeric(circ))) {
      stop("circ must be numeric")
      }
  
    diam <- circ / (pi * 100) # Calculate diameters in m
    mean_diam <- mean(diam, na.rm = na_act) # Calculate the mean 
    if(!(is.null(digits))) { # Round the diameter only if a value is provided for digits
      mean_diam <- round(mean_diam, digits = digits)
    }
    return(mean_diam) # Return the mean diameter
}
```
:::

::: fragment
```{r, eval = FALSE}
mean_diam(vec_char)
```

```{r, echo = FALSE}
try(mean_diam(vec_char))
```
:::

::: notes
warning can be used independently of return, in this case the execution continues
:::

## Using [if/else]{style="color:indianred;"} outside a function

We have seen many examples of use of [if/else]{style="color:indianred;"} inside a function, but we can also use it outside:

* at the beginning of a script, together with a warning or a stop, to check if the data are valid

* in a Quarto or R Markdown document, to adapt the output of a chunk depending on it result

* ...


::: notes
for quarto => we could either print "the statistical test is significant" or "the statistical test not significant", by performing a test on the p-value
:::


# Loops

<!-- TO CONTINUE-->

for, while, repeat, next, break...

inclure some tips on how to write

* https://frbcesab.github.io/tips-and-tricks/posts/2024-11-19-the-apply-function-family/
  * https://ericmarcon.github.io/Cours-travailleR/31-Langage.html#72

# debugging?

et dÃ©buggage basique avec print (cf Juba https://juba.github.io/tidyverse/20-debuggage-performance.html) mais le faire Ã  la fin de session 2 car possible aussi dans une boucle hors function


# Functional and scoped programming with the [tidyverse]{style="color:indianred;"}



accross, where, everything => follow Juba
reprendre mon example de Likert scale but do it accross columns

purr::map ici (avec un exemple using mean_diam_func on dataset in a list par ex)

rowwise and c_across

mentionner apply family

inclure purr::map? ici ou avec accross ? juste le mentionner ici et revenir dessus avec accross?

<!--ðŸ”¹ Option 1 â€“ map() en session 1
Si tu veux :

renforcer lâ€™utilitÃ© des fonctions personnalisÃ©es,

montrer un usage concret et rapide,

ne pas alourdir la session 2.

ðŸ”¹ Option 2 â€“ map() en session 2
Si tu veux :

regrouper les approches â€œapply-likeâ€ (across, map, etc.),

comparer diffÃ©rents paradigmes dâ€™application de fonctions (par colonnes, par Ã©lÃ©ments, par lignes),

introduire map2() ou pmap() avec les autres constructions avancÃ©es.

--> 

