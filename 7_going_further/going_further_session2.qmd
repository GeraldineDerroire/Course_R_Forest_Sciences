---
title: "Going further with R - session 2/2"
author: G√©raldine Derroire
institute: Cirad - UnB
date: last-modified
format: 
  revealjs:
    theme: solarized
    output-location: fragment 
    slide-number: true
    preview-links: true
    chalkboard: true
    link-external-icon: true
    link-external-newwindow: true
    incremental: true
execute:
  echo: true   
  warning: true
  message: true 
  cache: true
editor: 
  markdown: 
    wrap: sentence
---

# 

Let's load the package we will use:

```{r}
#| message: false
library(tidyverse)
```


```{r, echo=FALSE}
set.seed(14)
```


# Conditional execution

**Conditional execution** means running different blocks of code depending on whether a condition is TRUE or FALSE.

## if

[Let's write a function saying *Bom dia* only in the morning:]{style="font-size: 30px"}

```{r}
greeting <- function(time) {
  time <- hm(time) 
  time_limit <- hm("11:59")
  if (time < time_limit) {
    message("Bom dia !")
  } 
}
```

[üí° The function [hm]{style="color:indianred;"} from [lubridate]{style="color:indianred;"} convert a character to a period object.]{style="font-size: 25px"}

::: fragment
```{r}
greeting("8:13")
```
:::

::: fragment
```{r}
greeting("14:25")
```
:::

::: notes
very important function for me!!!
:::

## if 

![](if.png)

The command [if]{style="color:indianred;"} is used with:

* a condition (in parentheses)

* a block of code (in curly brackets) that is executed only if the condition is TRUE


## if / else

[Let's update our function to say *Boa tarde* in the afternoon:]{style="font-size: 30px"}

```{r}
greeting <- function(time) {
  time <- hm(time) 
  time_limit <- hm("11:59")
  if (time < time_limit) {
    message("Bom dia !")
  } else {
    message("Boa tarde !")
  }
}
```

[[and test it:]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r}
greeting("8:13")
```
:::

::: fragment
```{r}
greeting("14:25")
```
:::

## if/else

An [if]{style="color:indianred;"} instruction can be followed by a [else]{style="color:indianred;"} that is executed if the condition of [if]{style="color:indianred;"} is FALSE.

![](if_else.png)

## if/else if/else

[But what to say in the evening?]{style="font-size: 30px"}

::::: columns
::: {.column width="60%"}

```{r}
greeting <- function(time) {
  time <- hm(time) 
  time_limit1 <- hm("11:59")
  time_limit2 <- hm("17:59")
  if (time < time_limit1) {
    message("Bom dia !")
  } else if (time < time_limit2) {
    message("Boa tarde !")
  } else {
    message("Boa noite !")
  }
}
```

:::

::: {.column width="40%"}

[[let's check]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r}
greeting("8:13")
```
:::

::: fragment
```{r}
greeting("14:25")
```
:::

::: fragment
```{r}
greeting("20:17")
```
:::
:::
:::::

## if/else if/else

We can add a second condition with [else if]{style="color:indianred;"}. 
The second condition is tested only if the 1st condition is FALSE.

![](if_else_if_else.png)


## Order of conditions

[Only the block of the first TRUE condition is executed.]{style="font-size: 30px"}

[‚ö†Ô∏è **The order of conditions is therefore important!**]{style="font-size: 30px"}

```{r}
greeting_wrong <- function(time) {
  time <- hm(time) 
  time_limit1 <- hm("11:59")
  time_limit2 <- hm("17:59")
  if (time < time_limit2) {
    message("Boa tarde !")
  } else if (time < time_limit1) {
    message("Bom dia !")
  } else {
    message("Boa noite !")
  }
}
```

::: fragment

ü•¥

```{r}
greeting_wrong("8:13")
```
:::

::: notes
explain what happen following the code
:::

## 

[üí° Now that we understand, we can use a more concise syntax for our function:]{style="font-size: 30px"}

```{r}
greeting <- function(time) {
  if (hm(time)  < hm("11:59")) {
    message("Bom dia !")
  } else if (hm(time)  < hm("17:59")) {
    message("Boa tarde !")
  } else {
    message("Boa noite !")
  }
}
```

::: notes
if removed the 3 first lines and included the hm() in the tests
:::


## Example of use

[We can modify our function *mean_diam* so that it rounds the diameter only if a value is given to the argument digits.]{style="font-size: 30px"}
[[For that we give the default value NULL to the argument *digits*, and add a test before rounding:]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r}
mean_diam <- function(circ, na_act = TRUE, digits = NULL) {
    diam <- circ / (pi * 100) # Calculate diameters in m
    mean_diam <- mean(diam, na.rm = na_act) # Calculate the mean 
  # Round the diameter only if a value is provided for digits
    if(!(is.null(digits))) {
      mean_diam <- round(mean_diam, digits = digits)
    }
    return(mean_diam) # Return the mean diameter
}
```
:::

::: fragment
```{r}
new_circ <- runif(n = 35, min = 30, max = 250)
mean_diam(new_circ)
```
::: 

::: fragment
```{r}
mean_diam(new_circ, digits = 2)
```
::: 

::: notes
function mean_diam seen in the previous session: change the units of diameter, take the mean and round it
:::

## Another example 

What does this function do?

```{r}
graph_var <- function(v) { # v: a vector
    if (is.character(v)) {
        barplot(table(v))
    } else if (is.numeric(v)) {
        hist(v)
    } else {
        message("The type of v is not supported by the function")
    }
}
```

## Another example 

[Let's check:]{style="font-size: 30px"}

::::: columns
::: {.column width="50%"}
```{r}
v_char <- sample(LETTERS[1:5], 100, 
                 replace = TRUE)
graph_var(v_char)
```


:::

::: {.column width="50%"}
```{r}
v_num <- runif(100, min=0, max=10)
graph_var(v_num)
```

:::
:::::

```{r}
vec_logical <- sample(c(TRUE, FALSE), 100, replace = TRUE)
graph_var(vec_logical)
```

## Writing conditions

[To write conditions, we use can:]{style="font-size: 30px"}

* [logical operator: [<]{style="color:indianred;"}, [>]{style="color:indianred;"}, [<=]{style="color:indianred;"}, [>=]{style="color:indianred;"}, [%in%]{style="color:indianred;"}, [==]{style="color:indianred;"}, [!=]{style="color:indianred;"}, [any]{style="color:indianred;"}, [all]{style="color:indianred;"}...]{style="font-size: 30px"}

* [type checking functions: [is.numeric]{style="color:indianred;"}, [is.character]{style="color:indianred;"}, [is.logical]{style="color:indianred;"}...]{style="font-size: 30px"}

[[and combine them using [&&]{style="color:indianred;"} and [||]{style="color:indianred;"}]{style="font-size: 30px"}]{.fragment}

[[üí° [&&]{style="color:indianred;"} and [||]{style="color:indianred;"} are equivalent to [&]{style="color:indianred;"} and [|]{style="color:indianred;"} but only work for vector of length one. There are therefore safer to use in if/else conditions, as they need to return only one value.]{style="font-size: 30px"}]{.fragment}

## More complex conditions

Should we go the the party?

```{r}
tricky_decision <- function(cool_people, good_music) { # booleans
  if(cool_people && good_music) {
    message("Go!") 
  } else if (cool_people || good_music) {
    message("Maybe...")
  } else {
    message("No way!")
  }
}
```

[üí° As the expected values for the two arguments are booleans, we don't need to write == TRUE.]{style="font-size: 30px"}

::: notes
Let's see if you remember how to combine tests...
What does this function do?
:::

## More complex conditions

```{r}
tricky_decision(cool_people = TRUE, good_music = TRUE)
```

```{r}
tricky_decision(cool_people = TRUE, good_music = FALSE)
```

```{r}
tricky_decision(cool_people = FALSE, good_music = TRUE)
```

```{r}
tricky_decision(cool_people = FALSE, good_music = FALSE)
```

## More complex conditions

What does this function do?

```{r}
check_input <- function(x, valid_val) {
  if(length(x) != 1 || !(x %in% valid_val)) {
    cat(x, "is an invalid input.")
  } else {
    cat(x, "is a valid input.")
  }
}
```

::: fragment
```{r}
check_input(x = 2, valid_val = 1:10)
```
:::

::: fragment
```{r}
check_input(x = 25, valid_val = 1:10)
```
:::

::: fragment
```{r}
check_input(x = c(2,3), valid_val = 1:10)
```
:::

::: notes
a valid input is in the list of valid input and has a lenght of 1
:::





## if/else and ifelse

[‚ö†Ô∏è [if/else]{style="color:indianred;"} and [ifelse]{style="color:indianred;"} (or its [tidyverse]{style="color:indianred;"} equivalent [if_else]{style="color:indianred;"}) are very different:]{style="font-size: 30px"}

::::: columns
::: {.column width="50%"}

* [[if/else]{style="color:indianred;"} is used when testing a single condition and execute different blocks of code depending on its result:]{style="font-size: 30px"}

::: fragment
```{r}
x <- 5
if (x >= 10) {
    message(">=10")
} else {
    message("<10")
}
```
:::
:::

::: {.column width="50%"}
* [[ifelse]{style="color:indianred;"} and [if_else]{style="color:indianred;"} apply a test to all the elements of a vector and return a vector whose elements depend on the result of each test:]{style="font-size: 30px"}

::: fragment
```{r}
x <- 5:15
ifelse(x >= 10, ">=10", "<10")
```
:::
:::
:::::


## Using [if/else]{style="color:indianred;"} to control the execution of a function

[Our function [mean_diam]{style="color:indianred;"} is intended to be used on a numerical vector. It returns an error otherwise:]{style="font-size: 30px"}

```{r, eval = FALSE}
vec_char <- c("A", "B")
mean_diam(vec_char)
```
```{r, echo= FALSE}
vec_char <- c("A", "B")
try(mean_diam(vec_char))
```

[[This error is not explicit for a user, as they don't know what *circ/(pi \* 100)* is used for...]{style="font-size: 30px"}]{.fragment}


## Using [if/else]{style="color:indianred;"} with [warning]{style="color:indianred;"}

[We can add a test to return *NA* when *circ* is not numeric, and add an explicit warning message:]{style="font-size: 30px"}

```{r}
mean_diam <- function(circ, na_act = TRUE, digits = NULL) {
    if(!(is.numeric(circ))) {
      warning("circ is not numeric, the result is NA")
      return(NA) # if circ is not numeric, the execution stops here
    }
  
    diam <- circ / (pi * 100) # Calculate diameters in m
    mean_diam <- mean(diam, na.rm = na_act) # Calculate the mean 
    if(!(is.null(digits))) { # Round the diameter only if a value is provided for digits
      mean_diam <- round(mean_diam, digits = digits)
    }
    return(mean_diam) # Return the mean diameter
}
```

::: fragment
```{r}
mean_diam(vec_char)
```
:::

::: notes
Many parenthesis, click on a closing one to see which one it closes
:::

## Using [if/else]{style="color:indianred;"} with [stop]{style="color:indianred;"}

[[warning]{style="color:indianred;"} does not stop the execution of the function (in our previous slide it's [return]{style="color:indianred;"} that stopped it).]{style="font-size: 30px"}


[[On the contrary, [stop]{style="color:indianred;"} triggers an error that stops the execution:]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r}
mean_diam <- function(circ, na_act = TRUE, digits = NULL) {
    if(!(is.numeric(circ))) {
      stop("circ must be numeric")
      }
  
    diam <- circ / (pi * 100) # Calculate diameters in m
    mean_diam <- mean(diam, na.rm = na_act) # Calculate the mean 
    if(!(is.null(digits))) { # Round the diameter only if a value is provided for digits
      mean_diam <- round(mean_diam, digits = digits)
    }
    return(mean_diam) # Return the mean diameter
}
```
:::

::: fragment
```{r, eval = FALSE}
mean_diam(vec_char)
```

```{r, echo = FALSE}
try(mean_diam(vec_char))
```
:::

::: notes
warning can be used independently of return, in this case the execution continues
:::

## Using [if/else]{style="color:indianred;"} outside a function

We have seen many examples of use of [if/else]{style="color:indianred;"} inside a function, but we can also use it outside:

* at the beginning of a script, together with a warning or a stop, to check if the data are valid

* in a Quarto or R Markdown document, to adapt the output of a chunk depending on it result

* ...


::: notes
for quarto => we could either print "the statistical test is significant" or "the statistical test not significant", by performing a test on the p-value
:::


# Loops

A loop allows to repeatedly executes a block of code.

## [for]{style="color:indianred;"} loop

Let's take a simple example:

```{r}
for (item in 1:5) {
    print(item)
}
```
## [for]{style="color:indianred;"} loop

![](for_loop.png){width=350%}



::::: columns
::: {.column width="60%"}

A [for]{style="color:indianred;"} loop executes a block of code for each element of a vector.
For each iteration, the loop sequentially assigns a value from the vector to the loop iterator.

:::

::: {.column width="40%"}

::: fragment

[*In our example:* *item* take the value 1, and the block of code prints it, then 
*item* take the value 2, and the block of code prints it, then ..., then 
*item* take the value 5, and the block of code prints it]{style="font-size: 25px"}

:::

:::
:::::


## [for]{style="color:indianred;"} loop

The vector can be of any mode, and we can give any name to the  iterator (usually we use *n* or *i*)

```{r}
vec_name <- c("Lucas", "Gabriel", "Ana", "Maria", "Jo√£o")
for (name in vec_name) {
  message("Hello ", name, "!")
}
```
[Here the vector is of type *character* and the iterator is called *name*.]{.fragment}

## Iterating over elements

In the previous example

```{r, eval = FALSE}
for (name in vec_name) {
  message("Hello ", name, "!")
}
```


we iterate over the **elements** (the values) of a vector.


<!--

* iterer sur une valeur (cf Juba) 


across colum? -->

## Iterating over numeric indices

We can also iterate over **numeric indices**:

```{r}
for (n in seq_along(vec_name)) {
  message("Hello ", vec_name[[n]], "!")
}
```

::: fragment

The function [seq_along]{style="color:indianred;"} returns a sequence of integers from 1 to the length of a vector.

```{r}
seq_along(vec_name)
```
:::

## Iterating over numeric indices

Instead of *seq_along(vec_name)*, we could also write *1:length(vec_name)*:

```{r}
for (n in 1:length(vec_name)) {
  message("Hello ", vec_name[[n]], "!")
}
```

[‚ö†Ô∏è seq_along is safer]{.fragment}

## Iterating over numeric indices {.smaller}

[Let's take a vector of length 0:]{style="font-size: 30px"}

```{r}
vec_null <- NULL
length(vec_null)
```

[[The loop should not be executed:]{style="font-size: 30px"}]{.fragment}

::::: columns
::: {.column width="50%"}

* [Using *1:length()* will not behave as expected:]{style="font-size: 30px"}

::: fragment
```{r}
for (n in 1:length(vec_null)) {
  message("Hello ", vec_null[[n]], "!")
}
```
:::
:::

::: {.column width="50%"}

* [Using will behave as expected (it does nothing):]{style="font-size: 30px"}

::: fragment
```{r}
for (n in seq_along(vec_null)) {
  message("Hello ", vec_null[[n]], "!")
}
```
:::
:::
:::::

[[Why is that?]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r}
1:length(vec_null)
seq_along(vec_null)
```
:::

## Iterating over numeric indices {.scrollable}

[Iterating over numeric indices is useful when we want to use the index (the iterator) in more than one purpose within the loop:]{style="font-size: 30px"}

```{r}
for (m in seq_along(month.name)) {
  month <- month.name[[m]]
  rank <- m
  message(month, " is the month ", rank)
}
```
<!-- CONTINUE FROM HERE -->

## 
 
* iterate over names (cf r4ds) 

across colum? 

across element of a list

* output of a loop 

r4ds: importance to create the output of the loop instead of increasing the output at every step (faster)

see also https://adv-r.hadley.nz/control-flow.html#control-flow common pitfall

* loop to modify

r4ds

* interateur kept out of the loop (Juba)


## [while]{style="color:indianred;"} loops

* juba

* ex of r4ds flipping a coin

## next and break

## repeat loop

?
untill a break 


## when not to use a loop

when vectorised alternative Juba and here https://thinkr.fr/comment-faire-des-boucles-en-r-ou-pas/

group by and summarise rather than for loop per group

et enchainer sur accross and purr...





##

<!-- TO CONTINUE-->

for, while, repeat, next, break...

inclure some tips on how to write







# Functional and scoped programming with the [tidyverse]{style="color:indianred;"}

voir si je commence avec map???

accross, where, everything => follow Juba
reprendre mon example de Likert scale but do it accross columns

rowwise and c_across

purr::map ici (avec un exemple using mean_diam_func on dataset in a list par ex)
parler aussi de walk (in r4ds)
parler aussi de reduce??? r4ds

## The [apply]{style="color:indianred;"} family

Not covered but here is a good ressource:

https://frbcesab.github.io/tips-and-tricks/posts/2024-11-19-the-apply-function-family/

inclure purr::map? ici ou avec accross ? juste le mentionner ici et revenir dessus avec accross?

<!--üîπ Option 1 ‚Äì map() en session 1
Si tu veux :

renforcer l‚Äôutilit√© des fonctions personnalis√©es,

montrer un usage concret et rapide,

ne pas alourdir la session 2.

üîπ Option 2 ‚Äì map() en session 2
Si tu veux :

regrouper les approches ‚Äúapply-like‚Äù (across, map, etc.),

comparer diff√©rents paradigmes d‚Äôapplication de fonctions (par colonnes, par √©l√©ments, par lignes),

introduire map2() ou pmap() avec les autres constructions avanc√©es.

--> 

# Debugging

![](debugging.png){width=90%}

::: notes
what is important is how happy you feel when you manage!
::: 

##

a good start: avoid having to debug by checking the code (especially in function and loops) carrefully => select some sensible test data, try to anticipate potential problem...

but we cannot think of everything...
Here just some basic way of debugging

if not too long, run a function or a loop line by one with the problematic dataset, to see where it buggs

otherwise : use print

et d√©buggage basique avec print (cf Juba https://juba.github.io/tidyverse/20-debuggage-performance.html) mais le faire √† la fin de session 2 car possible aussi dans une boucle hors function

there are more advanced debugging tools...

# Acknowledgments {.smaller}

::: {.nonincremental}

* Barnier J. *Introduction √† R et au tidyverse* [in French](https://juba.github.io/tidyverse/){preview-link="false"}

<!--
* *Introduction √† l‚Äôanalyse d‚Äôenqu√™tes avec R et RStudio* - Julien Barnier, Julien Biaudet, Fran√ßois Briatte, Milan Bouchet-Valat, Ewen Gallic, Fr√©d√©rique Giraud, Jo√´l Gombin, Mayeul Kauffmann, Christophe Lalanne, Joseph Larmarange, Nicolas Robette [in French](https://larmarange.github.io/analyse-R/){preview-link="false"}
-->

:::

# Ressources

::: {.nonincremental}

:::
