---
title: "Introduction to the tidyverse"
author: Géraldine Derroire
institute: Cirad - UnB
date: last-modified
format: 
  revealjs:
    theme: solarized
    output-location: fragment 
    slide-number: true
    preview-links: true
    chalkboard: true
    link-external-icon: true
    link-external-newwindow: true
    incremental: true
execute:
  echo: true   
  warning: true
  message: true 
editor: 
  markdown: 
    wrap: sentence
---

# What is the tidyverse?

## What is the tidyverse?

The name *tidyverse* come from *tidy* and *universe*. 

::::: columns
::: {.column width="70%"}
* A group of packages with a coherent syntax

* Based on the idea of *tidy* data

* Optimise the readability and functionality of the code (*designed for humans*)

* Easy to sequence commands (using a *pipe*)

:::

::: {.column width="30%"}
![](tidyverse.png)
:::
:::::


## Installing the tidyverse

We just need to install and load the package tidyverse:

```{r}
library(tidyverse)
```

::: notes
You should already have installed the package tidyverse
:::


## Core packages of the tidyverse

This loads the "core" packages of the tidyverse:

::::: columns
::: {.column width="50%"}
* [[tibble]{style="color:indianred;"} for tibbles, a modern re-imagining of data frames]{style="font-size: 30px"}

* [[readr]{style="color:indianred;"} for data import]{style="font-size: 30px"}

* [[tidyr]{style="color:indianred;"} for data tidying]{style="font-size: 30px"}

* [[stringr]{style="color:indianred;"} for strings]{style="font-size: 30px"}

:::

::: {.column width="50%"}
* [[forcats]{style="color:indianred;"} for factors]{style="font-size: 30px"}

* [[lubridate]{style="color:indianred;"} for date/times]{style="font-size: 30px"}

* [[dplyr]{style="color:indianred;"} for data manipulation]{style="font-size: 30px"}

* [[ggplot2]{style="color:indianred;"} for data visualisation]{style="font-size: 30px"}

* [[purrr]{style="color:indianred;"} for functional programming]{style="font-size: 30px"}
:::
:::::


## Tidy data

The "concept" of tidy data has been proposed by Hadley Wickham [(2014)](https://www.jstatsoft.org/article/view/v059i10) to make data easy to manipulate and clean.

::::: columns
::: {.column width="70%"}
The principles are:

* each variable is a column

* each observation is a row

* each type of observational unit is a table


:::

::: {.column width="30%"}
![](dataframe.png)
:::
:::::

[All the packages of the tidyverse require tidy data.]{.fragment}

::: notes
we have seen this figure when we talked about data frame.
Tidy data are in a data frame, but all data frame are not necessarly tidy.
Data frame is a structure, but it is possible to use it in a messy way.
:::


## Tibbles

All the packages of the tidyverse use objects of class [tibble]{style="color:indianred;"}, which is an evolution of the classic data frame.

The main difference is that tibble don't have row names.

Tibbles are compatible with data frames, and most of the tidyverse packages accept data frames.


## Pipe

Commands can be executed one after the other using a pipe [%>% ]{style="color:indianred;"}:

```{r}
1:10 %>% 
  sqrt %>% 
  sum
```

[is equivalent to]{.fragment}

::: fragment
```{r}
sum(sqrt(1:10))
```
:::

[but much easier to read.]{.fragment}

::: notes 
what did we do?
:::

## Pipe


::::: columns
::: {.column width="50%"}
The pipe is introduced by the package [magritt ]{style="color:indianred;"}, but is also loaded with the tidyverse.

[It can be accessed using the shortcut [Ctrl + Shuft + m]{style="color:indianred;"}]{.fragment}
:::

::: {.column width="50%"}
![](pipe.png)

![](magritt.png)
:::
:::::


::: notes
René Magritte: Belgium surrealist artist
:::




## Workflow

![](workflow.png)

::: notes
In the tidyverse the steps of importing, tidying and transforming data is called "wrangling"
:::


# Let's work with data on trees of French Guiana

## Functional trait data of trees

*‘‘Functional traits are defined as morpho-physio-phenological traits which impact fitness indirectly via their effects on growth, reproduction and survival, the three components of individual performance.’’* Violle *et al* [2007](https://nsojournals.onlinelibrary.wiley.com/doi/10.1111/j.0030-1299.2007.15559.x)

::::: columns
::: {.column width="70%"}
These data are available in the package rcontroll (Schmitt *et al* [2023](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.14215)),
but were are going to import a slighly modified version from a csv file available 
[here](https://geraldinederroire.github.io/Course_R_Forest_Sciences/4_tidyverse/data/func_traits.csv){preview-link="false"}.
:::

::: {.column width="30%"}
![](rcontroll.png)
:::
:::::


## Commercial tree species

We will also use data on commercial species.

::::: columns
::: {.column width="70%"}
These data are available in the package LoggingLab (Badouard *et al* [2024](https://www.sciencedirect.com/science/article/abs/pii/S0304380023002697)),
but were are going to import them from a csv file available 
[here](https://geraldinederroire.github.io/Course_R_Forest_Sciences/4_tidyverse/data/commercial_sp.csv){preview-link="false"}.
:::


::: {.column width="30%"}
![](logginglab.png)
:::
:::::


# Import data with the package [readr]{style="color:indianred;"}

::: notes
remember, the core packages are already loaded with the tidyverse, so no need to load them one by one
:::

## Importing a csv file

We use the function [read_csv]{style="color:indianred;"} to import the trait data from the csv file.

```{r}
traits <- read_csv("data/func_traits.csv")
```
::: notes
change the path to your relative path in your project
:::

## Importing a csv file

[read_csv]{style="color:indianred;"} is the tidyverse equivalent of [read.csv]{style="color:indianred;"}, but:

* it returns a tibble (which is also a data frame)

::: fragment
```{r}
class(traits)
```
:::

* it is faster


::: notes
tbl_df a subclass of data.frame to distinguish its behaviour from these of other tibble (explain that some functions performs different things depending of the class of the object)

spec_tbl_df store the columns specification (as seen here)
:::

## Functional trait data of trees

Let's look at the functional trait data:

```{r}
traits
```

[[To know more, we can look at the help on the package rcontroll:]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r, eval=FALSE}
?rcontroll::TROLLv3_species
```
:::

::: notes
but package rcontroll is probably not installed...
:::

## Transform data frame into tibble

Let's import the data on commercial trees as a regular data frame:

```{r}
sp_com <- read.csv("data/commercial_sp.csv")
class(sp_com)
```

[and transform it into a tibble using the function [as_tibble]{style="color:indianred;"}:]{.fragment}

::: fragment
```{r}
sp_com <- as_tibble(sp_com)
class(sp_com)
```
:::

## Transform data frame into tibble

⚠️ Remember that tibbles don't have row names.

So if there was row names that we want to keep in our data frame, we should use the function [rownames_to_column]{style="color:indianred;"} to put them in a column (but let's not store it here).

```{r}
as.tibble(rownames_to_column(sp_com))
```

::: notes
here we just look at the results but don't store them
:::

## Commercial tree species

Let's look at the sp_com data :

```{r}
sp_com
```

[[To know more, we can look at the help on the package LoggingLab (if you want to install it, see instructions [here](https://vincyanebadouard.github.io/LoggingLab/))]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r, eval=FALSE}
?LoggingLab::SpeciesCriteria
```
:::

::: notes
explain that the package is not on the cran
:::


# Manipulate and transform with the package [dplyr]{style="color:indianred;"}

## The verbs of [dplyer]{style="color:indianred;"}

::::: columns
::: {.column width="70%"}
The package [dplyr]{style="color:indianred;"} proposes an intuitive syntax to manipulate and transform data.

The names of the functions are verbs that relate to the use of the function.

dplyr functions accept *data frame* and *tibble* and return a *tibble*.
:::

::: {.column width="30%"}
![](dplyr.png)
:::
:::::

## Operations on rows

::: {.nonincremental}
* slice

* filter

* arrange

* distinct

::: 


## slice

The function [slice]{style="color:indianred;"} selects row(s) according to its/their position(s).

```{r}
slice(traits, 25)
```
[which is equivalent to:]{.fragment}

::: fragment
```{r}
traits[25,]
```
:::

## slice

and also equivalent to:

```{r}
traits %>% 
  slice(25)
```

## slice

We can also get several rows:

```{r}
slice(traits, 2:8)
```

## slice

We can select only the first (or last) ones using [slice_head]{style="color:indianred;"} or [slice_tail]{style="color:indianred;"}:

```{r}
slice_head(traits, n=3) # n specify the number of rows
```
::: fragment
```{r}
slice_tail(traits, prop=0.1) # prop specify the proportion of rows
```
:::

## slice

[slice_min]{style="color:indianred;"} and [slice_max]{style="color:indianred;"} selects the row with the smallest or biggest value for a given variable:

```{r}
slice_min(traits, s_dbhmax)
```

::: fragment
```{r}
traits %>% 
  slice_max(s_hmax)
```

:::

::: notes
the two ways of writing it (using the pipe or not) are equivalent
:::

## filter

The function [filter]{style="color:indianred;"} selects rows according to a condition (a test).
Only the rows for which the result of the test is TRUE are selected.

[Let's select only the aggregative species in the commercial species dataset:]{style="font-size: 30px"}

```{r}
filter(sp_com, Aggregative == TRUE)
```


## filter

Or let's select the species that have a wood specific gravity (wsg) lower than 0.4:

```{r}
filter(traits, s_wsg < 0.4)
```


::: notes
Remember the logical operators of comparisons that we have seen two sessions ago?
:::

## filter

We can also combine several conditions:

```{r}
filter(traits, 
       s_wsg < 0.4 & # first condition
         s_LMA > 70) # second condition
```
[There are no species satisfying these two conditions in our dataset.]{.fragment}

::: notes
we could write it only on one line, it's just for readability
:::


## filter

We can also use a function to specify the condition.

Let's select trees with maximum DBH higher than the median:

```{r}
filter(traits, s_dbhmax > median(s_dbhmax))
```


## arrange

The function [arrange]{style="color:indianred;"} reorders the row according to one or several columns:

Let's sort the species by increasing order of WSG, **and then** by decreasing order of hmax:

```{r}
arrange(traits, 
        s_wsg, # increasing
        desc(s_hmax)) # decreasing
```

::: notes
use desc for decreasing
:::

## distinct

The function [distinct]{style="color:indianred;"} keep only rows that are distinct.

[Let's create a simple dataset with a duplicated row:]{style="font-size: 26px"}

```{r}
my_tibble <- tibble(name = c("Lucia", "Lucia", "Anna"),
                    age = c(21, 21, 23))
my_tibble
```

[[and use [distinct]{style="color:indianred;"} to keep only distinct rows:]{style="font-size: 26px"}]{.fragment}

::: fragment
```{r}
distinct(my_tibble)
```
:::


https://larmarange.github.io/guide-R/manipulation/dplyr.html#distinct

## Operations on columns

::: {.nonincremental}
* select

* rename

* mutate

* relocate

:::

## select

The function [select]{style="color:indianred;"} selects columns:

Let's select the Commercial names, Genus and Species from sp_com:

```{r}
select(sp_com, CommercialName, Genus, Species)
```

## select

We can also say the columns we don't want to select using [select]{style="color:indianred;"}.

Let's select all the columns but the commercial name, using [-]{style="color:indianred;"} before the name of the column to exclude:

```{r}
select(sp_com, - CommercialName)
```

## select

We can use functions to express a conditions on the column names: [starts_with]{style="color:indianred;"}, [ends_with]{style="color:indianred;"}, [contains]{style="color:indianred;"}...

::::: columns
::: {.column width="50%"}
```{r}
# columns starting with "com"
select(sp_com, starts_with("Com")) 
```
:::

::: {.column width="50%"}

::: fragment
```{r}
# columns containing "FD"
select(sp_com, contains("FD")) 
```
:::
:::
:::::


[[See the package [tidyselect]{style="color:indianred;"} for more...]{style="font-size: 25px"}]{.fragment}

## rename

We can rename columns with the function [rename]{style="color:indianred;"}:

```{r}
rename(traits, 
       LMA = s_LMA) # start with the new name
```



## mutate

The function [mutate]{style="color:indianred;"} creates new columns, using existing ones.

[Let's create a new column in the traits dataset to have the DBHmax in cm:]{style="font-size: 25px"}


```{r}
mutate(traits,
       dbhmax_cm = s_dbhmax * 100) %>% # add the new column dbhmax_cm
  select(Genus, Species, s_dbhmax, dbhmax_cm) %>%  # select only the 4 columns of interest
  slice_head(n=5) # just the 5 first rows
```


::: notes
here we use a pipe to follow with the function select to only show the column we are interested in.

But of course, mutate could be used on its own!
:::

## relocate

We can reorder the columns using the function [relocate]{style="color:indianred;"}.
We just need to specify the columns we want to put first (the order of the other ones is unchanged).

[Let's move the columns of DBHmax and Hmax first (after the species name) in the trait dataset:]{style="font-size: 25px"}

```{r}
relocate(traits, Genus, Species, s_dbhmax, s_hmax) %>% 
  slice_head(n=5) # just the 5 first rows
```

::: notes
show that the number of columns/variables has NOT changed, just the order
:::

## Grouped operations

::: {.nonincremental}
* group_by

* summarise

* count

:::


## group_by 

The function [group_by]{style="color:indianred;"} allow grouping rows according to the values of a column.

[Let's group the table of traits by Genus]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% group_by(Genus)
```
:::

::: {.column width="30%"}
[There is no apparent change in the tibble, except the mention of the grouping.]{.fragment}
:::
:::::

::: notes
show that the tibble has still the same dimensions
:::

## group_by with slice

When groups have been defined, we can apply further operations on these groups by using other functions.

[Let's select the species with the maximum wsg **for each Genus**, using [slice_max]{style="color:indianred;"}:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  group_by(Genus) %>% 
  slice_max(s_wsg) 
```
:::

::: {.column width="30%"}
[We see that the resulting tibble has as many rows as there are genus.]{.fragment}
:::
:::::

::: notes
note the change of dimension!
:::

## group_by

We can also use group_by with [mutate]{style="color:indianred;"} to do an operation by group.

[Let's calculate the mean wsg of each Genus:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  group_by(Genus) %>%
  mutate(mean_wsg = mean(s_wsg)) %>% 
  select(Genus, Species, s_wsg, mean_wsg) # select only the columns of interest
```
:::

::: {.column width="30%"}
[Here all rows are kept and species of a same genus have the same value for mean_wsg]{.fragment}
:::
:::::

::: notes
all rows are j=kept as we didn't do a selection on rows
:::

## group_by

We can check this by looking at the Licania for instance:


```{r}
traits %>% 
  group_by(Genus) %>%
  mutate(mean_wsg = mean(s_wsg)) %>% # add the mean wsg
  select(Genus, Species, s_wsg, mean_wsg) %>% # select only the columns of interest
  filter(Genus == "Licania") # only the Licania
```


## group_by 

We can also use group_by with [filter]{style="color:indianred;"} to select according to a conditions applied **on each group**.

[Let's look at the species that have a higher wsg than the mean of their Genus:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  group_by(Genus) %>% 
  filter(s_wsg > mean(s_wsg)) %>% 
  select(Genus, Species, s_wsg) # select only the columns of interest
```
:::

```{r, echo=FALSE}
dim_res <- traits %>% 
  group_by(Genus) %>% 
  filter(s_wsg > mean(s_wsg)) %>% 
  select(Genus, Species, s_wsg) %>% 
  dim()
```


::: {.column width="30%"}
[[Here there are `r dim_res[1]` species that have a wsg higher than the mean of their genus.]{style="font-size: 25px"}]{.fragment}
:::
:::::

::: notes
Here most of the genus have just one species, so their wsg is not stricly > to the mean
:::

## summarise

The function [summarise]{style="color:indianred;"} aggregates the row by performing a summary operation on one or several columns.

[Let's look at the min, max and mean values of wsg accross the dataset:]{style="font-size: 25px"}

```{r}
traits %>% 
  summarise(min_wsg = min(s_wsg),
            max_wsg = max(s_wsg),
            mean_wsg = mean(s_wsg))
```

[*Note that here only the summary columns are kept.*]{.fragment}

## summarise

The function [summarise]{style="color:indianred;"} can be used together with [group_by]{style="color:indianred;"} to summarise *by group*.

[Let's look at the min, max and mean values of wsg by Genus:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  group_by(Genus) %>% 
  summarise(min_wsg = min(s_wsg),
            max_wsg = max(s_wsg),
            mean_wsg = mean(s_wsg))
```
:::

::: {.column width="30%"}
[*Here there are as many row than there are groups.*]{.fragment}
:::
:::::

## count

The function [count]{style="color:indianred;"} counts the number of rows per group.

[Let's count the number of Species per Genus:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  count(Genus)
```
:::


::: {.column width="30%"}
[[We see that the genus *Couepia* has two species.]{style="font-size: 25px"}]{.fragment}

:::
:::::

## Grouping according to several columns

The functions [group_by]{style="color:indianred;"} and [count]{style="color:indianred;"} can be used to group on several columns.

[Let's go back to the dataset on commercial species and count the number of Species per Genus and per commercial name:]{style="font-size: 25px"}

::::: columns
::: {.column width="60%"}
```{r}
sp_com %>% 
  count(Genus, CommercialName)
```
:::

::: {.column width="40%"}
[[We see that the genus *Brosimum* has three species, all with a different commercial name.]{style="font-size: 25px"}]{.fragment}

[[We see for instance that the Genus *Caryocar* has two species for which the commercial name is chawari.]{style="font-size: 25px"}]{.fragment}
:::
:::::

::: notes
Look at the Carapa and Caryocar
:::


## Using a pipe to chain the different operations

We can a pipe [%>%]{style="color:indianred;"}  to chain several operations.

The result of each operation feeds into the next one.

[⚠️ Don't forget to put the result of a pipe in a new (or existing) object.]{.fragment}

[When writing a pipe, write the operations one by one and **test them one by one**.]{.fragment}

[The first thing to check is if the dimensions of the tibble have changed, and if you were expecting it to change.]{.fragment}


## Using a pipe to chain the different operations


::::: columns
::: {.column width="65%"}
```{r}
gen_dim_max <- traits %>% 
  select(Genus, Species, s_hmax, s_dbhmax) %>% 
  rename(Hmax = s_hmax,
         DBHmax = s_dbhmax) %>% 
  mutate(BAmax = (DBHmax/2)^2 * pi) %>% 
  group_by(Genus) %>% 
  summarise(Hmax_mean = mean(Hmax),
            DBHmax_mean = mean(DBHmax),
            BAmax_mean = mean(BAmax)) %>% 
  arrange(desc(BAmax_mean))
```

[What did we do?]{.fragment}

:::

::: {.column width="35%"}
* [select 4 columns]{style="font-size: 25px"}

* [rename 2 columns]{style="font-size: 25px"}

* [add the basal area max]{style="font-size: 25px"}

* [group by genus]{style="font-size: 25px"}

* [calculate mean dimensions by genus]{style="font-size: 25px"}

* [sort the table by decreasing order of BAmax_mean]{style="font-size: 25px"}

* [store the result in *gen_dim_max*]{style="font-size: 25px"}

:::
:::::

<!-- carry on from here--> 

## Combining multiple tables

## bind_rows and bind_cols

## The joints

Several functions allows to join two tibbles (*here x and y*) using a key (or several).

[[A key is a column (or group of column) that is used to match rows when joining two datasets.]{style="font-size: 30px"}]{.fragment}
[[⚠️ A key need to uniquely identify observations in one or both datasets (otherwise there will be several combinations of matches).]{style="font-size: 30px"}]{.fragment}

::::: columns
::: {.column width="50%"}
* [left_join]{style="color:indianred;"} keeps all rows in x

* [right_join]{style="color:indianred;"} keeps all rows in y
:::

::: {.column width="50%"}
* [inner_join]{style="color:indianred;"} keeps only rows from x that have a matching key in y

* [full_join]{style="color:indianred;"} keeps all the rows in x and y
:::
:::::

::: notes 
say here that very important to check the dim
:::

## left_join

give an example for all here (and explain the dims with a test)

## and many other functions... [](https://rstudio.github.io/cheatsheets/html/data-transformation.html){preview-link="false"} 

![](dplyr_cheatsheet.png){width="30%"}


::: notes
end of the first session??? or before after the joint???
:::

# Ranger avec le package *tidyr*

Mais si les données ne sont pas bien rangées => on range

ici utiliser un jeu de données bordéliques... en créer un ?

https://ericmarcon.github.io/Cours-travailleR/32-Tidyverse.html#15 et suivante

https://biodiversitydata.github.io/chapters/data-cleaning.html

https://larmarange.github.io/guide-R/manipulation_avancee/tidyr.html

https://juba.github.io/tidyverse/12-tidyr.html


les slides d'Eric sont bien pour les visuels, mais voir aussi Allison Horst

function unite

function separate

pivot_longer / wider

fonction complete?

## package *janitor*

not part of the tidyverse but compatible 
https://biodiversitydata.github.io/chapters/data-cleaning.html


# package *forcats* for qualitative variables

https://juba.github.io/tidyverse/09-recodages.html#combiner-plusieurs-variables


# package *stringr*

https://biodiversitydata.github.io/chapters/data-cleaning.html

https://larmarange.github.io/guide-R/manipulation_avancee/stringr.html

https://juba.github.io/tidyverse/11-stringr.html


# package *lubidate*

https://biodiversitydata.github.io/chapters/data-cleaning.html

# 

# TO DECIDE

## dire ggplot on va voir après




## Acknowledgments

Eric

https://biodiversitydata.github.io/chapters/data-cleaning.html 

juba

## Ressources

cheatsheet of each of the tidyverse package

* Wickham, H. . (2014). Tidy Data. Journal of Statistical Software, 59(10), 1–23. [https://doi.org/10.18637/jss.v059.i10](https://doi.org/10.18637/jss.v059.i10)

