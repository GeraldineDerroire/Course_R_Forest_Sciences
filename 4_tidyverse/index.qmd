---
title: "Introduction to the tidyverse"
author: Géraldine Derroire
institute: Cirad - UnB
date: last-modified
format: 
  revealjs:
    theme: solarized
    output-location: fragment 
    slide-number: true
    preview-links: true
    chalkboard: true
    link-external-icon: true
    link-external-newwindow: true
    incremental: true
execute:
  echo: true   
  warning: true
  message: true 
editor: 
  markdown: 
    wrap: sentence
---

# What is the tidyverse?

## What is the tidyverse?

The name *tidyverse* come from *tidy* and *universe*. 

::::: columns
::: {.column width="70%"}
* A group of packages with a coherent syntax

* Based on the idea of *tidy* data

* Optimise the readability and functionality of the code (*designed for humans*)

* Easy to sequence commands (using a *pipe*)

:::

::: {.column width="30%"}
![](tidyverse.png)
:::
:::::


## Installing the tidyverse

We just need to install and load the package tidyverse:

```{r}
library(tidyverse)
```

::: notes
You should already have installed the package tidyverse
:::


## Core packages of the tidyverse

This loads the "core" packages of the tidyverse:

::::: columns
::: {.column width="50%"}
* [[tibble]{style="color:indianred;"} for tibbles, a modern re-imagining of data frames]{style="font-size: 30px"}

* [[readr]{style="color:indianred;"} for data import]{style="font-size: 30px"}

* [[tidyr]{style="color:indianred;"} for data tidying]{style="font-size: 30px"}

* [[stringr]{style="color:indianred;"} for strings]{style="font-size: 30px"}

:::

::: {.column width="50%"}
* [[forcats]{style="color:indianred;"} for factors]{style="font-size: 30px"}

* [[lubridate]{style="color:indianred;"} for date/times]{style="font-size: 30px"}

* [[dplyr]{style="color:indianred;"} for data manipulation]{style="font-size: 30px"}

* [[ggplot2]{style="color:indianred;"} for data visualisation]{style="font-size: 30px"}

* [[purrr]{style="color:indianred;"} for functional programming]{style="font-size: 30px"}
:::
:::::


## Tidy data

The "concept" of tidy data has been proposed by Hadley Wickham [(2014)](https://www.jstatsoft.org/article/view/v059i10) to make data easy to manipulate and clean.

::::: columns
::: {.column width="70%"}
The principles are:

* each variable is a column

* each observation is a row

* each type of observational unit is a table


:::

::: {.column width="30%"}
![](dataframe.png)
:::
:::::

[All the packages of the tidyverse require tidy data.]{.fragment}

::: notes
we have seen this figure when we talked about data frame.
Tidy data are in a data frame, but all data frame are not necessarly tidy.
Data frame is a structure, but it is possible to use it in a messy way.
:::


## Tibbles

All the packages of the tidyverse use objects of class [tibble]{style="color:indianred;"}, which is an evolution of the classic data frame.

The main difference is that tibble don't have row names.

Tibbles are compatible with data frames, and most of the tidyverse packages accept data frames.


## Pipe

Commands can be executed one after the other using a pipe [%>% ]{style="color:indianred;"}:

```{r}
1:10 %>% 
  sqrt %>% 
  sum
```

[is equivalent to]{.fragment}

::: fragment
```{r}
sum(sqrt(1:10))
```
:::

[but much easier to read.]{.fragment}

::: notes 
what did we do?
:::

## Pipe


::::: columns
::: {.column width="50%"}
The pipe is introduced by the package [magritt ]{style="color:indianred;"}, but is also loaded with the tidyverse.

[It can be accessed using the shortcut [Ctrl + Shuft + m]{style="color:indianred;"}]{.fragment}
:::

::: {.column width="50%"}
![](pipe.png)

![](magritt.png)
:::
:::::


::: notes
René Magritte: Belgium surrealist artist
:::




## Workflow

![](workflow.png)

::: notes
In the tidyverse the steps of importing, tidying and transforming data is called "wrangling"
:::


# Let's work with data on trees of French Guiana

## Functional trait data of trees

*‘‘Functional traits are defined as morpho-physio-phenological traits which impact fitness indirectly via their effects on growth, reproduction and survival, the three components of individual performance.’’* Violle *et al* [2007](https://nsojournals.onlinelibrary.wiley.com/doi/10.1111/j.0030-1299.2007.15559.x)

::::: columns
::: {.column width="70%"}
These data are available in the package rcontroll (Schmitt *et al* [2023](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.14215)),
but were are going to import a slighly modified version from a csv file available 
[here](https://geraldinederroire.github.io/Course_R_Forest_Sciences/4_tidyverse/data/func_traits.csv){preview-link="false"}.
:::

::: {.column width="30%"}
![](rcontroll.png)
:::
:::::


## Commercial tree species

We will also use data on commercial species.

::::: columns
::: {.column width="70%"}
These data are available in the package LoggingLab (Badouard *et al* [2024](https://www.sciencedirect.com/science/article/abs/pii/S0304380023002697)),
but were are going to import them from a csv file available 
[here](https://geraldinederroire.github.io/Course_R_Forest_Sciences/4_tidyverse/data/commercial_sp.csv){preview-link="false"}.
:::


::: {.column width="30%"}
![](logginglab.png)
:::
:::::


# Import data with the package [readr]{style="color:indianred;"}

::: notes
remember, the core packages are already loaded with the tidyverse, so no need to load them one by one
:::

## Importing a csv file

We use the function [read_csv]{style="color:indianred;"} to import the trait data from the csv file.

```{r}
traits <- read_csv("data/func_traits.csv")
```
::: notes
change the path to your relative path in your project
:::

## Importing a csv file

[read_csv]{style="color:indianred;"} is the tidyverse equivalent of [read.csv]{style="color:indianred;"}, but:

* it returns a tibble (which is also a data frame)

::: fragment
```{r}
class(traits)
```
:::

* it is faster


::: notes
tbl_df a subclass of data.frame to distinguish its behaviour from these of other tibble (explain that some functions performs different things depending of the class of the object)

spec_tbl_df store the columns specification (as seen here)
:::

## Functional trait data of trees

Let's look at the functional trait data:

```{r}
traits
```

[[To know more, we can look at the help on the package rcontroll:]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r, eval=FALSE}
?rcontroll::TROLLv3_species
```
:::

::: notes
but package rcontroll is probably not installed...
:::

## Transform data frame into tibble

Let's import the data on commercial trees as a regular data frame:

```{r}
sp_com <- read.csv("data/commercial_sp.csv")
class(sp_com)
```

[and transform it into a tibble using the function [as_tibble]{style="color:indianred;"}:]{.fragment}

::: fragment
```{r}
sp_com <- as_tibble(sp_com)
class(sp_com)
```
:::

## Transform data frame into tibble {.scrollable}

⚠️ Remember that tibbles don't have row names.

So if there was row names that we wanted to keep in our data frame, we should use the function [rownames_to_column]{style="color:indianred;"} to put them in a column (but let's not store it here).

```{r}
as_tibble(rownames_to_column(sp_com))
```

::: notes
here we just look at the results but don't store them
:::

## Commercial tree species {.scrollable}

Let's look at the sp_com data :

```{r}
sp_com
```

[[To know more, we can look at the help on the package LoggingLab (if you want to install it, see instructions [here](https://vincyanebadouard.github.io/LoggingLab/))]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r, eval=FALSE}
?LoggingLab::SpeciesCriteria
```
:::

::: notes
explain that the package is not on the cran
:::


# Manipulate and transform with the package [dplyr]{style="color:indianred;"}

## The verbs of [dplyr]{style="color:indianred;"}

::::: columns
::: {.column width="70%"}
The package [dplyr]{style="color:indianred;"} proposes an intuitive syntax to manipulate and transform data.

The names of the functions are verbs that relate to the use of the function.

dplyr functions accept *data frame* and *tibble* and return a *tibble*.
:::

::: {.column width="30%"}
![](dplyr.png)
:::
:::::

## Operations on rows

::: {.nonincremental}
* slice

* filter

* arrange

* distinct

::: 


## slice

The function [slice]{style="color:indianred;"} selects row(s) according to its/their position(s).

```{r}
slice(traits, 25)
```
[which is equivalent to:]{.fragment}

::: fragment
```{r}
traits[25,]
```
:::

## slice

and also equivalent to:

```{r}
traits %>% 
  slice(25)
```

## slice

We can also get several rows:

```{r}
slice(traits, 2:8)
```

## slice

We can select only the first (or last) ones using [slice_head]{style="color:indianred;"} or [slice_tail]{style="color:indianred;"}:

```{r}
slice_head(traits, n=3) # n specify the number of rows
```
::: fragment
```{r}
slice_tail(traits, prop=0.1) # prop specify the proportion of rows
```
:::

## slice

[slice_min]{style="color:indianred;"} and [slice_max]{style="color:indianred;"} selects the row with the smallest or biggest value for a given variable:

```{r}
slice_min(traits, s_dbhmax)
```

::: fragment
```{r}
traits %>% 
  slice_max(s_hmax)
```

:::

::: notes
the two ways of writing it (using the pipe or not) are equivalent
:::

## filter

The function [filter]{style="color:indianred;"} selects rows according to a condition (a test).
Only the rows for which the result of the test is TRUE are selected.

[Let's select only the aggregative species in the commercial species dataset:]{style="font-size: 30px"}

```{r}
filter(sp_com, Aggregative == TRUE)
```


## filter

Or let's select the species that have a wood specific gravity (wsg) lower than 0.4:

```{r}
filter(traits, s_wsg < 0.4)
```


::: notes
Remember the logical operators of comparisons that we have seen two sessions ago?

Ask them if they know the cecropia
:::

## filter

We can also combine several conditions:

```{r}
filter(traits, 
       s_wsg < 0.4 & # first condition
         s_LMA > 70) # second condition
```
[There are no species satisfying these two conditions in our dataset.]{.fragment}

::: notes
we could write it only on one line, it's just for readability
:::


## filter {.scrollable}

We can also use a function to specify the condition.

Let's select species with maximum DBH higher than the median:

```{r}
filter(traits, s_dbhmax > median(s_dbhmax))
```

::: notes
in the dataset we have 45 values, so when we get the one above the median we get 22
=> it makes sense
:::

## arrange {.scrollable}

The function [arrange]{style="color:indianred;"} reorders the row according to one or several columns:

Let's sort the species by increasing order of WSG, **and then** by decreasing order of hmax:

```{r}
arrange(traits, 
        s_wsg, # increasing
        desc(s_hmax)) # decreasing
```

::: notes
use desc for decreasing
:::

## distinct {.scrollable}

The function [distinct]{style="color:indianred;"} keep only rows that are distinct.

[Let's create a simple dataset with a duplicated row:]{style="font-size: 26px"}

```{r}
my_tibble <- tibble(name = c("Lucia", "Lucia", "Anna"),
                    age = c(21, 21, 23))
my_tibble
```

[[and use [distinct]{style="color:indianred;"} to keep only distinct rows:]{style="font-size: 26px"}]{.fragment}

::: fragment
```{r}
distinct(my_tibble)
```
:::



## Operations on columns

::: {.nonincremental}
* select

* rename

* mutate

* relocate

:::

## select

The function [select]{style="color:indianred;"} selects columns:

Let's select the Commercial names, Genus and Species from sp_com:

```{r}
select(sp_com, CommercialName, Genus, Species)
```

## select {.scrollable}

We can also say the columns we don't want to select using [select]{style="color:indianred;"}.

Let's select all the columns except the commercial name, using [-]{style="color:indianred;"} before the name of the column to exclude:

```{r}
select(sp_com, - CommercialName)
```

## select

We can use functions to express a conditions on the column names: [starts_with]{style="color:indianred;"}, [ends_with]{style="color:indianred;"}, [contains]{style="color:indianred;"}...

::::: columns
::: {.column width="50%"}
```{r}
# columns starting with "com"
select(sp_com, starts_with("Com")) 
```
:::

::: {.column width="50%"}

::: fragment
```{r}
# columns containing "FD"
select(sp_com, contains("FD")) 
```
:::
:::
:::::


[[See the package [tidyselect]{style="color:indianred;"} for more...]{style="font-size: 25px"}]{.fragment}

## rename

We can rename columns with the function [rename]{style="color:indianred;"}:

```{r}
rename(traits, 
       LMA = s_LMA) # start with the new name
```



## mutate

The function [mutate]{style="color:indianred;"} creates new columns, using existing ones.

[Let's create a new column in the traits dataset to have the DBHmax in cm:]{style="font-size: 25px"}


```{r}
mutate(traits,
       dbhmax_cm = s_dbhmax * 100) %>% # add the new column dbhmax_cm
  select(genus, species, s_dbhmax, dbhmax_cm) %>%  # select only the 4 columns of interest
  slice_head(n=5) # just the 5 first rows
```


::: notes
here we use a pipe to follow with the function select to only show the column we are interested in.

But of course, mutate could be used on its own!
:::

## relocate

We can reorder the columns using the function [relocate]{style="color:indianred;"}.
We just need to specify the columns we want to put first (the order of the other ones is unchanged).

[Let's move the columns of DBHmax and Hmax first (after the species name) in the trait dataset:]{style="font-size: 25px"}

```{r}
relocate(traits, genus, species, s_dbhmax, s_hmax) %>% 
  slice_head(n=5) # just the 5 first rows
```

::: notes
show that the number of columns/variables has NOT changed, just the order
:::

## Grouped operations

::: {.nonincremental}
* group_by

* summarise

* count

:::


## group_by 

The function [group_by]{style="color:indianred;"} allow grouping rows according to the values of a column.

[Let's group the table of traits by genus]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% group_by(genus)
```
:::

::: {.column width="30%"}
[There is no apparent change in the tibble, except the mention of the grouping.]{.fragment}
:::
:::::

::: notes
show that the tibble has still the same dimensions
:::

## group_by with slice

When groups have been defined, we can apply further operations on these groups by using other functions.

[Let's select the species with the maximum wsg **for each genus**, using [slice_max]{style="color:indianred;"}:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  group_by(genus) %>% 
  slice_max(s_wsg) 
```
:::

::: {.column width="30%"}
[We see that the resulting tibble has as many rows as there are genus.]{.fragment}
:::
:::::

::: notes
note the change of dimension!

show them the number of rows and the number of genus
:::

## group_by with mutate {.scrollable}

We can also use [group_by]{style="color:indianred;"} with [mutate]{style="color:indianred;"} to do an operation by group.

[Let's calculate the mean wsg of each genus:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  group_by(genus) %>%
  mutate(mean_wsg = mean(s_wsg)) %>% 
  select(genus, species, s_wsg, mean_wsg) # select only the columns of interest
```
:::

::: {.column width="30%"}
[Here all rows are kept and species of a same genus have the same value for mean_wsg]{.fragment}
:::
:::::

::: notes
all rows are j=kept as we didn't do a selection on rows
:::

## group_by with mutate

We can check this by looking at the *Licania* for instance:


```{r}
traits %>% 
  group_by(genus) %>%
  mutate(mean_wsg = mean(s_wsg)) %>% # add the mean wsg
  select(genus, species, s_wsg, mean_wsg) %>% # select only the columns of interest
  filter(genus == "Licania") # only the Licania
```


## group_by with filter

We can also use [group_by]{style="color:indianred;"} with [filter]{style="color:indianred;"} to select according to a conditions applied **on each group**.

[Let's look at the species that have a higher wsg than the mean of their genus:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  group_by(genus) %>% 
  filter(s_wsg > mean(s_wsg)) %>% 
  select(genus, species, s_wsg) # select only the columns of interest
```
:::

```{r, echo=FALSE}
dim_res <- traits %>% 
  group_by(genus) %>% 
  filter(s_wsg > mean(s_wsg)) %>% 
  select(genus, species, s_wsg) %>% 
  dim()
```


::: {.column width="30%"}
[[Here there are `r dim_res[1]` species that have a wsg higher than the mean of their genus.]{style="font-size: 25px"}]{.fragment}
:::
:::::

::: notes
Here most of the genus have just one species, so their wsg is not stricly > to the mean
:::

## summarise

The function [summarise]{style="color:indianred;"} aggregates the row by performing a summary operation on one or several columns.

[Let's look at the min, max and mean values of wsg accross the dataset:]{style="font-size: 25px"}

```{r}
traits %>% 
  summarise(min_wsg = min(s_wsg),
            max_wsg = max(s_wsg),
            mean_wsg = mean(s_wsg))
```

[*Note that here only the summary columns are kept.*]{.fragment}

## summarise {.scrollable}

The function [summarise]{style="color:indianred;"} can be used together with [group_by]{style="color:indianred;"} to summarise *by group*.

[Let's look at the min, max and mean values of wsg by genus:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  group_by(genus) %>% 
  summarise(min_wsg = min(s_wsg),
            max_wsg = max(s_wsg),
            mean_wsg = mean(s_wsg))
```
:::

::: {.column width="30%"}
[*Here there are as many rows than there are groups.*]{.fragment}
:::
:::::

## count

The function [count]{style="color:indianred;"} counts the number of rows per group.

[Let's count the number of species per genus:]{style="font-size: 25px"}

::::: columns
::: {.column width="70%"}
```{r}
traits %>% 
  count(genus)
```
:::


::: {.column width="30%"}
[[We see that the genus *Couepia* has two species.]{style="font-size: 25px"}]{.fragment}

:::
:::::

## Grouping according to several columns {.scrollable}

The functions [group_by]{style="color:indianred;"} and [count]{style="color:indianred;"} can be used to group on several columns.

[Let's go back to the dataset on commercial species and count the number of Species per Genus and per commercial name:]{style="font-size: 25px"}

::::: columns
::: {.column width="60%"}
```{r}
sp_com %>% 
  count(Genus, CommercialName)
```
:::

::: {.column width="40%"}
[[We see that the genus *Brosimum* has three species, all with a different commercial name.]{style="font-size: 25px"}]{.fragment}

[[We see for instance that the genus *Caryocar* has two species for which the commercial name is chawari.]{style="font-size: 25px"}]{.fragment}
:::
:::::

::: notes
Look at the Carapa and Caryocar
:::


## Using a pipe to chain the different operations

We can use a pipe [%>%]{style="color:indianred;"} to chain several operations.

The result of each operation feeds into the next one.

[⚠️ Don't forget to put the result of a pipe in a new (or existing) object.]{.fragment}

[When writing a pipe, write the operations one by one and **test them one by one**.]{.fragment}

[The first thing to check is if the dimensions of the tibble have changed, and if you were expecting it to change.]{.fragment}


## Using a pipe to chain the different operations  {.scrollable}


::::: columns
::: {.column width="61%"}
```{r}
gen_dim_max <- traits %>% 
  select(genus, species, s_hmax, s_dbhmax) %>% 
  rename(Hmax = s_hmax,
         DBHmax = s_dbhmax) %>% 
  mutate(BAmax = (DBHmax/2)^2 * pi) %>% 
  group_by(genus) %>% 
  summarise(Hmax_mean = mean(Hmax),
            DBHmax_mean = mean(DBHmax),
            BAmax_mean = mean(BAmax)) %>% 
  arrange(desc(BAmax_mean))

gen_dim_max 
```


:::
::: {.column width="39%"}
[[What did we do?]{style="font-size: 25px"}]{.fragment}

* [select 4 columns]{style="font-size: 23px"}

* [rename 2 columns]{style="font-size: 23px"}

* [add the basal area max]{style="font-size: 23px"}

* [group by genus]{style="font-size: 23px"}

* [calculate mean dimensions by genus]{style="font-size: 23px"}

* [sort the table by decreasing order of BAmax_mean]{style="font-size: 23px"}

* [store the result in *gen_dim_max*]{style="font-size: 23px"}

:::
:::::


::: notes
This could be the end of the session 1/2
::: 


## Combining multiple tables

::: {.nonincremental}
* Concatenation

* Joint

:::

## Concatenation

The functions [bind_rows]{style="color:indianred;"} and [bind_cols]{style="color:indianred;"} allow to add rows and columns, respectively, from one or several tables.

## bind_rows

[To understand how [bind_rows]{style="color:indianred;"} works, we will first create several datasets of traits that are subsets from the one we have used so far.
This is obviously only for the purpose of the exercise...]{style="font-size: 25px"}

::::: columns
::: {.column width="65%"}
```{r}
traits1 <- traits %>% 
  slice(1:2)
```

::: fragment
```{r}
traits2 <- traits %>% 
  select(, - s_wsg, - s_hmax) %>% 
  slice(25:26)
```
:::

::: fragment
```{r}
traits3 <- traits %>% 
  select(, -s_LMA) %>% 
  slice(25:27)
```
:::
:::

::: {.column width="35%"}
::: fragment
```{r}
dim(traits1)
```
:::

::: fragment
```{r}
dim(traits2)
```
:::

::: fragment
```{r}
dim(traits3)
```
:::
:::
:::::

::: notes
in some of the table, some columns are now missing
:::


## bind_rows

We can use [bind_row]{style="color:indianred;"} to concatenate the three table by rows.

```{r}
bind_rows(traits1, traits2, traits3)
```

[When the columns were missing in some tables, the values have been filled with *NA*.]{.fragment}


## bind_rows {.scrollable}

If we want to keep track of which table the rows came from, we can use the argument [.id]{style="color:indianred;"} and specify the name of the column in which we want to store this information (here *"source"*).

We can also explicitly give a name to each table.

```{r}
bind_rows(table1 = traits1, table2 = traits2, table3 = traits3,
          .id ="source")
```

## bind_cols

[bind_cols]{style="color:indianred;"} works in a similar way but to concatenate columns.

```{r}
# let's first make subset tables
t1 <- traits %>% slice(1:2) %>% select(genus, species)
t2 <- traits %>% slice(1:2) %>% select(s_LMA)
t3 <- traits %>% slice(1:2) %>% select(s_wsg)
```

::: fragment
```{r}
bind_cols(t1, t2, t3)
```
:::


[⚠️ The columns are matched only by position, so the rows needs to correspond (and there must be the same number of rows).
A safer option is to use *joints* to combine several tables by columns.]{.fragment}


## The joints

Several functions allows to join two tibbles (*here x and y*) using a key (or several).

[[A key is a column (or group of columns) that is used to match rows when joining two datasets.]{style="font-size: 30px"}]{.fragment}
[[⚠️ A key need to uniquely identify observations in one or both datasets (otherwise there will be several combinations of matches).]{style="font-size: 30px"}]{.fragment}

::::: columns
::: {.column width="50%"}
* [left_join]{style="color:indianred;"} keeps all rows in x

* [right_join]{style="color:indianred;"} keeps all rows in y
:::

::: {.column width="50%"}
* [inner_join]{style="color:indianred;"} keeps only rows from x that have a matching key in y

* [full_join]{style="color:indianred;"} keeps all the rows in x and y
:::
:::::

::: notes 
say here that very important to check the dim
:::



## The joints

We are now going to join the dataset of traits and the dataset of commercial species.

Let's first select a subset of columns in each, to visualise the results better.

```{r}
traits_sub <- traits %>% select(genus, species, s_LMA, s_wsg)
sp_com_sub <- sp_com %>% select(CommercialName, Genus, Species)
```

::: fragment
```{r}
colnames(traits_sub)
```
:::

::: fragment
```{r}
colnames(sp_com_sub)
```
:::

[Both datasets have a column for the genus and a column for the species, which we can use as *keys*.
But the columns names are not exactly written in the same way.]{.fragment}

## left_join {.scrollable}

We can join *traits_sub* with *sp_com_sub* using a [left_join]{style="color:indianred;"}.

[[We need to specify which column matches which (as they are no columns with the exact same names in both datasets).]{style="font-size: 30px"}]{.fragment}

::: fragment
```{r}
j1 <- traits_sub %>% 
  left_join(sp_com_sub,
            by = c("genus" = "Genus",
                   "species" = "Species"))
j1
```
:::


## left_join

We can see that [left_join]{style="color:indianred;"} kept all rows of *traits_sub*,

::: fragment
```{r}
dim(j1)[1] == dim(traits_sub)[1]
```
:::

[and that *NA* have been added when there was not match in *sp_com_sub*.]{.fragment}

::: fragment
```{r}
slice_head(j1, n=5) # show only a few line for ease of reading
```
:::


::: notes
I encourage you to do this kind of test of dimension

explian how we did the test
:::


## righ_joint

We can join *traits_sub* with *sp_com_sub* using a [right_join]{style="color:indianred;"}.

```{r}
j2 <- traits_sub %>% 
  right_join(sp_com_sub,
            by = c("genus" = "Genus",
                   "species" = "Species"))
```

[We can see that [right_join]{style="color:indianred;"} kept all rows of *sp_com_sub*.]{.fragment}

::: fragment
```{r}
dim(j2)[1] == dim(sp_com_sub)[1]
```
:::

[Here as well, *NA* have been added when there was not match in *traits_sub*.]{.fragment}


## inner_join

Let's now use a [inner_join]{style="color:indianred;"}.

::::: columns
::: {.column width="60%"}
```{r}
j3 <- traits_sub %>% 
  inner_join(sp_com_sub,
            by = c("genus" = "Genus",
                   "species" = "Species"))
dim(j3)[1]
```
:::


::: {.column width="40%"}
[The [inner_join]{style="color:indianred;"} keeps only rows from *traits_sub* that have a matching key in *sp_com_sub*.]{.fragment}
:::
:::::

[So there are `r dim(j3)[1]` species common to *traits_sub* and *sp_com_sub*.]{.fragment}

## full_join

Let's now use a [full_join]{style="color:indianred;"}.

::::: columns
::: {.column width="60%"}
```{r}
j4 <- traits_sub %>% 
  full_join(sp_com_sub,
            by = c("genus" = "Genus",
                   "species" = "Species"))
dim(j4)[1]
```
:::

::: {.column width="40%"}
[The [full_join]{style="color:indianred;"} keeps all the rows in x and y]{.fragment}
:::
:::::

[So there are `r dim(j4)[1]` species in total in  *traits_sub* and *sp_com_sub*.]{.fragment}

::: fragment
```{r}
dim(j4)[1]  == dim(traits_sub)[1] + dim(sp_com_sub)[1] - dim(j3)[1]
```
:::

[[🤔 What did we do here?]{style="font-size: 35px"}]{.fragment}
[[We checked that the total number of species is equal to the sum of the number of species in each datasets minus the number of common species.]{style="font-size: 35px"}]{.fragment}



##

We have seen some of the main functions of dplyr...

but there are many other more...[](https://rstudio.github.io/cheatsheets/html/data-transformation.html){preview-link="false"} 

![](dplyr_cheatsheet.png){width="30%"}


::: notes
end of the first session??? or before after the joint???
:::



# Tidy a dataset with with the package [tidyr]{style="color:indianred;"}



## The verbs of [tidyr]{style="color:indianred;"}

With [dplyr]{style="color:indianred;"}, we have seen how to manipulate and transform tidy data.
But what to do when data are non-tidy? 

::::: columns
::: {.column width="70%"}
[We are going to use the package [tidyr]{style="color:indianred;"} to make messy (untidy) data tidy, so that we can use them with all the packages of the tidyverse.]{.fragment}

[Just as [dplyr]{style="color:indianred;"}, the syntax of [tidyr]{style="color:indianred;"} is based on intuitive verbs, and commands can be chained using a pipe ([%>%]{style="color:indianred;"}).]{.fragment}
:::

::: {.column width="30%"}
![](tidyr.png)
:::
:::::


## Let's load some untidy data

Today we are going to work with several dummy datasets, created only to serve as examples.

They are available as a .Rdata file [here](https://geraldinederroire.github.io/Course_R_Forest_Sciences/4_tidyverse/data/data_tidyverse_2.RData){preview-link="false"}

[A .Rdata file is a file that can contain several R objects.]{style="font-size: 25px"}

Let's load them in our environment:

```{r}
load("data/data_tidyverse_2.RData")
```

::: notes
! with their path
::: 

## First example of untidy data

Let's look at the dataset called *dt1* containing tree DBH for different years:

```{r}
dt1
```
[🤔 Why is it untidy? What are the variables in this table?]{.fragment}

[The variables are the *tree*, the *year* and the *DBH*.
These variable are NOT stored in columns.]{.fragment}


## pivot_longer

We can use the function [pivot_longer]{style="color:indianred;"} to put it in a  tidy format:

::::: columns
::: {.column width="70%"}
```{r}
dt1 %>% pivot_longer(c(`2015`, `2020`, `2025`)) 
```
:::

::: {.column width="30%"}
[We now have a column per variable, and a row per observation 😀]{.fragment}
:::
::::

::: notes
` ` indicate that these are column names and not numbers
:::


## pivot_longer {.scrollable}

We can specify the names of the columns that will be created:

```{r}
dt1L <- dt1 %>% 
  pivot_longer(c(`2015`, `2020`, `2025`),
               names_to = "year", # for the name of the former columns
               values_to = "DBH") # for the values contained in these columns
dt1L
```

## pivot_longer

[pivot_longer]{style="color:indianred;"} transform a table in a *wide format* to a table in a *long format*.

![](pivot_longer.png)

[Source: [tidyr cheatsheet](https://rstudio.github.io/cheatsheets/html/tidyr.html){preview-link="false"}]{style="font-size: 25px"}


## pivot_wider

The function [pivot_wider]{style="color:indianred;"} does the opposite of [pivot_longer]{style="color:indianred;"}:

```{r}
dt1L %>% pivot_wider(
  names_from = "year", # indicates where are the new column names
  values_from = "DBH") # indicates where are the values
```

[So we get back the wide table that we had initially.]{.fragment}

## pivot_wider

[pivot_wider]{style="color:indianred;"} transform a table in a *long format* to a table in a *wide format*.

![](pivot_wider.png)

[Source: [tidyr cheatsheet](https://rstudio.github.io/cheatsheets/html/tidyr.html){preview-link="false"}]{style="font-size: 25px"}


## Second example of untidy data

Let's look at the dataset called *dt2* containing several tree DBH for different species:

```{r}
dt2
```

[🤔 Why is it untidy?]{.fragment}

[The column *taxo* contains the family, genus and species names.
And there are several values of DBH in a single column.]{.fragment}

::: notes
cerado trees: Aroeira, Jatoba-da-mata and Pau-jacaré

there are two problems
:::

## separate

We can use the function [separate]{style="color:indianred;"} to separate the content of a column into several columns:

```{r}
dt2 <- dt2 %>% 
  separate(taxo, # name of the column we want to separate
           c("family", "genus", "species"), # names of the new columns 
           sep = "_") # separator
dt2
```


## unite 

The function [unite]{style="color:indianred;"} does the opposite of [separate]{style="color:indianred;"}.

Let's create a column to store the full species name:

```{r}
dt2 <- dt2 %>% 
  unite(full_name, # name of the column to create
        genus, species, # names of the columns to unite
        sep=" ", # separated by a space
        remove = FALSE) # keep the two original columns
dt2
```

## separate_rows {.scrollable}

We still have the problem of having several DBH in a single column. 🤔 How should we store them? 

[We should store each DBH (observation) in a separate row.]{.fragment}
[We can use the function [separate_rows]{style="color:indianred;"} to do this:]{.fragment}

::: fragment
```{r}
dt2 <- dt2 %>% 
  separate_rows(DBH, # column to separate
                sep =",") %>% # specify the separator
  mutate(DBH = as.numeric(DBH)) # to transform DBH to numeric
dt2
```
:::

::: notes
NB: we added a command to put DBH in a numeric otherwise it would be a character

By default, [separate_rows]{style="color:indianred;"} uses any character that is not a number or a letter as the separator, so we don't necesseraly need to specify it
:::


## complete

Let's go back to the first data set *db1L* and let's add a measurement for tree3 in 2017:

```{r}
dt1L <- dt1L %>% bind_rows(
  tibble(tree = "tree3", year = "2017", DBH = 43))
dt1L
```

## complete {.scrollable}

To add rows for the two other trees for 2017, we can use the function [complete]{style="color:indianred;"}.

The function [complete]{style="color:indianred;"} add rows for all missing combination of several columns.

```{r}
dt1L %>% complete(tree, year) # names of the columns for which we want all combinations
```

::: notes
use NA for missing values, but we could specify something else
:::


## The package [janitor]{style="color:indianred;"} 

::::: columns
::: {.column width="80%"}
To go further, the package [janitor]{style="color:indianred;"} has several useful functions to clean messy data.

```{r, message=FALSE}
library(janitor)
```

:::

::: {.column width="20%"}
![](janitor.png)
:::
:::::

[For example, these messy data:]{.fragment}

::: fragment
```{r}
dt3
```
:::

::: notes
we won't explore this package, I just mention it in case you need it.

could not to it if I'm really late
:::


## clean_names

The function [clean_names]{style="color:indianred;"} cleans the variable names:

* use a consistent format

* remove space and special characters

* convert *#* to *number* and *%* to *percent*

* ...

::: fragment
```{r}
dt3 <- dt3 %>% clean_names()
dt3
```
:::


## remove_empty

The function [remove_empty]{style="color:indianred;"} removes empty rows and/or columns:

```{r}
dt3 %>%  remove_empty()
```


[To know more on *janitor*](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html){preview-link="false"}


# Manipulating factors with the packages [forcats]{style="color:indianred;"} and [dplyr]{style="color:indianred;"}

## 

Let's use the dataset *dt4*, which is about on secondary forests.

```{r}
str(dt4)
```
[What are the levels of the factor *past_landuse*?]{.fragment}

::: fragment
```{r}
levels(dt4$past_landuse)
```
:::

## Recoding levels {.scrollable}

[[fct_recode]{style="color:indianred;"} allows to rename the levels:]{style="font-size: 28px"}

::: fragment
```{r}
dt4$past_landuse %>% fct_recode(
  "Milho" = "Corn", # new level = old level
  "Pastagem" = "Pasture",
  "Soja" = "Soybeans",
  "Cana-de-açúcar" = "Sugarcane",
  "Tomate" = "Tomatoes") %>% 
  levels()
```
:::

[[[fct_collapse]{style="color:indianred;"} allows grouping levels:]{style="font-size: 28px"}]{.fragment}

::: fragment
```{r}
dt4$past_landuse %>% fct_collapse(
  "Agriculture" = c("Corn", "Soybeans", "Sugarcane", "Tomatoes")) %>% 
  levels()
```
:::

[[see also [fct_other]{style="color:indianred;"} and [fct_lump]{style="color:indianred;"} to create a level *Other*]{style="font-size: 28px"}]{.fragment}

::: notes
as always first we put the new one, and then the old one
:::

## Re-ordering levels

[[fct_relevel]{style="color:indianred;"} allows changing the order of the levels:]{style="font-size: 28px"}

::: fragment
```{r}
dt4$past_landuse %>% fct_relevel(
  "Pasture", "Soybeans", "Sugarcane", "Tomatoes", "Corn") %>% 
  levels()
```
:::

[[[fct_reorder]{style="color:indianred;"} allows re-order the levels according to the values of another variable:]{style="font-size: 28px"}]{.fragment}

::: fragment
```{r}
dt4$past_landuse %>% fct_reorder(
  dt4$age,
  median) %>%  # re-order the factor according the median of the age 
  levels()
```
:::


::: notes
useful for graphs to set the order of the levels
:::


## Function [if_else]{style="color:indianred;"} {.scrollable}

[[if_else]{style="color:indianred;"} from the package [dplyr]{style="color:indianred;"} performs a test on a variable, and give a value if true and another if false:]{style="font-size: 28px"}

```{r}
dt4 %>% 
  mutate(age_cat = # add a new column
           if_else(dt4$age > 10, # test
                   "Older than 10yr", # value if test TRUE
                   "Younger than 10yr")) %>% # value if test  FALSE
  mutate(age_cat = as.factor(age_cat)) # transform to factor
```

::: notes
here if_gives a character so we then transform it to a factor
:::

## Function [case_when]{style="color:indianred;"} {.scrollable}

[case_when]{style="color:indianred;"} from the package [dplyr]{style="color:indianred;"} generalise if else to several tests (or groups of tests)

```{r}
dt4 %>% 
  mutate(category = 
           case_when(
             dt4$past_landuse != "Pasture" & dt4$age < 10 ~ # tests for the first case
               "Young after agriculture", # value for the first case
             dt4$past_landuse == "Pasture" & dt4$age < 10 ~ # tests for the second case
               "Young after pasture", # value for the second case
             TRUE ~ "old")) %>% # all the other cases
  mutate(category = as.factor(category)) # transform to factor
```

::: notes
here what we do is a bit complicated:

We have 3 cases

and the test for each case has two conditions

we could use case_when with a test with just one condition
:::



## Function [cut]{style="color:indianred;"}

[cut]{style="color:indianred;"} from the package [base]{style="color:indianred;"} divides a vector into classes:

```{r}
dt4 %>% mutate(age_class =
                 cut(dt4$age, # vector to divide
                     breaks = 4)) # number of class
```

# Manipulating character strings with the package [stringr]{style="color:indianred;"} 

## Concatenate character strings

The function [paste]{style="color:indianred;"} from the package [base]{style="color:indianred;"} concatenate two vectors of characters:

```{r}
v1 <- c("dark", "dark", "ligth", "dark", "light")
v2 <- c("blue", "pink", "red", "yellow", "pink")

paste(v1, v2, sep=" ")
```

[It is equivalent to the function [str_c]{style="color:indianred;"} from the package [stringr]{style="color:indianred;"}]{.fragment}

::: fragment
```{r}
v3 <- str_c(v1, v2, sep=" ")
v3
```
:::

[[*NB: if we want to concatenate columns of a data frame, we can also use [unite]{style="color:indianred;"}.*]{style="font-size: 30px"}]{.fragment}


## Split a character string

The opposite is the function [str_split]{style="color:indianred;"} :

::::: columns
::: {.column width="50%"}
```{r}
str_split(v3, # vector to split
          pattern = " ") # where to split
```
[It returns a list of vectors...]{.fragment}

:::


::: {.column width="50%"}

[or a matrix if we use simplify = TRUE:]{.fragment}

::: fragment
```{r}
str_split(v3, pattern = " ", 
          simplify = TRUE)
```
:::

[[*NB: if we want to separate columns of a data frame, we can also use [separate]{style="color:indianred;"}.*]{style="font-size: 30px"}]{.fragment}

:::
:::::



## More useful functions for character strings

::::: columns
::: {.column width="50%"}
* [Convert to upper/lower case: [str_to_lower]{style="color:indianred;"} and [str_to_upper]{style="color:indianred;"}]{style="font-size: 30px"}

::: fragment
```{r}
v <- c("one", "two")
v <- str_to_upper(v)
v
str_to_lower(v)
```
:::

:::

::: {.column width="50%"}
* [Extract substrings by position of the first and last character: [str_sub]{style="color:indianred;"}]{style="font-size: 30px"}

::: fragment
```{r}
v <- c("Brasil", "Mexico")
str_sub(v, start=1, end=3)
```
:::

:::
:::::


::::: columns
::: {.column width="50%"}
* [Detect a pattern: [str_detect]{style="color:indianred;"}]{style="font-size: 30px"}

::: fragment
```{r}
v <- c("Brasil", "Mexico")
str_detect(v, "Br")
```
:::

:::

::: {.column width="50%"}
* [Replace a pattern:  [str_replace_all]{style="color:indianred;"}]{style="font-size: 30px"}

::: fragment
```{r}
v <- c("Avenida Paulista", 
       "Avenida Atlântica")
str_replace_all(v, "Avenida", "AV.")
```
:::

:::
:::::


# Dealing with dates with the package [lubidate]{style="color:indianred;"}


![](lubridate.png){width=70%}

[Wickham H., Cetinkaya-Rundel M., Grolemund G. *R for Data Science*]{style="font-size: 25px"} 

[[in English](https://r4ds.hadley.nz/datetimes.html) and [in Portuguese](https://pt.r4ds.hadley.nz/){preview-link="false"}]{style="font-size: 25px"}

::: notes
delaing with dates can be complicated in R, if you need to use dates, check the package lubridate
:::

# Graphics with the package [ggplot]{style="color:indianred;"}

*Next session!*

![](ggplot.png)



## Acknowledgments

::: {.nonincremental}

* Barnier J. *Introduction à R et au tidyverse* [in French](https://juba.github.io/tidyverse/){preview-link="false"}

* Marcon E. *R: Ridyverse* [in French](https://ericmarcon.github.io/Cours-travailleR/32-Tidyverse.html){preview-link="false"}

* Casajus N , Coux C. *Cleaning biodiversity data - Good practices, tools and homogenizing taxonomy* [in English](https://biodiversitydata.github.io/chapters/data-cleaning.html){preview-link="false"}

* Wickham H., Cetinkaya-Rundel M., Grolemund G. *R for Data Science* [in English](https://r4ds.hadley.nz/datetimes.html){preview-link="false"} and [in Portuguese](https://pt.r4ds.hadley.nz/){preview-link="false"}

:::

## Ressources

::: {.nonincremental}

* Wickham, H. . (2014). Tidy Data. Journal of Statistical Software, 59(10), 1–23. [https://doi.org/10.18637/jss.v059.i10](https://doi.org/10.18637/jss.v059.i10)

* Wickham H., Cetinkaya-Rundel M., Grolemund G. *R for Data Science* [in English](https://r4ds.hadley.nz/datetimes.html) and [in Portuguese](https://pt.r4ds.hadley.nz/)

* Cheatsheets of 
[dpyr](https://rstudio.github.io/cheatsheets/html/data-transformation.html){preview-link="false"},
[tidyr](https://rstudio.github.io/cheatsheets/html/tidyr.html){preview-link="false"},
[stringr](https://rstudio.github.io/cheatsheets/html/strings.html){preview-link="false"},
[forcats](https://www.flutterbys.com.au/stats/downloads/slides/figure/factors.pdf){preview-link="false"}

:::

